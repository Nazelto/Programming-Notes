[{"id":0,"href":"/Programming-Notes/docs/notes/","title":"Introduction","section":"Docs","content":"这是我的第一篇文章#\r"},{"id":1,"href":"/Programming-Notes/docs/notes/zig/zig-grammar/","title":"Zig Grammar","section":"Zig","content":"zig 语法#\r流程控制#\rif#\rif可用来解包可选类型(?) 与 错误类型(!)\nconst optional:?i32 = null; if (optional) |number:i32| { //something todo } const error: anyerror!i32 = 0; if (error) |number:i32| { //something todo }高级类型#\r指针#\r单项指针#\r单项指针指向单个元素。\n单项指针的类型为 *T，其中 T 是所指向的数据类型。解引用操作使用 ptr.*。\n// 代码来自 zig 语言圣经 const print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { var integer: i16 = 666; const ptr = \u0026amp;integer; ptr.* = ptr.* + 1; print(\u0026#34;{}\\n\u0026#34;, .{integer}); }多项指针#\r多项指针指向一个或多个连续的元素，但其数量在编译期是未知的。 TIP\n多项指针的类型为 [*]T，其中 T 是所指向的数据类型，且 T 的大小必须是明确的（这意味着它不能是 anyopaque 或其他不透明类型）\nconst print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { const array = [_]i32{ 1, 2, 3, 4 }; const ptr: [*]const i32 = \u0026amp;array; print(\u0026#34;第一个元素：{}\\n\u0026#34;, .{ptr[0]}); }多个指针的区别#\r[4] const u8 // 该类型表示一个长度为4的数组，里面的类型 [] const u8 // 这表示是一个 内部类型为 const u8 的切片 *[4] const u8 // 表示一个指针，该指针的地址存储一个长度为4，元素为const u8的数组 *[] const u8 //这表示指针地址存储着一个切片 [*] const u8 // 表示一个多项指针 元素为const u8 但是长度未知切片与数组#\r切片#\r切片本质上是一个胖指针，内部有一个[*] T的多项指针与切片长度。\nconst array: [_] i32 = [_]i32{1,2,3,4}; const slice:[] i32 = array[0..4];联合类型#\runion与tag union#\runion { int:i32, float:f32 };union的缺陷是他不知道自己存储的是什么类型的数据。而tag union就是来解决这个问题的。\nunion(enum) { a:i32, b:f32, };opaque 透明类型#\rNOTE\n几乎用不到的类型，这通常用于与 C 代码交互时，确保类型安全，尤其是在 C 代码没有公开结构体细节的情况下。\nconst wat = opauqe {};与C交互#\r引入C头文件#\rconst c = @import({ @cDefine(\u0026#34;_NO_CRT_STDIN_INLINE\u0026#34;,\u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); })引入 vcpkg#\r声明C函数#\r// 声明一个C的外部函数 extern \u0026#34;C\u0026#34; fn add (x:i32,y:i32) i32; // 导出一个函数给c export fn add(x:i32,y:i32) callconv(.c) i32 {};内存管理#\r以DebugAllocator为例.\n// 获取DebugAllocator实例 var gpa = std.heap.DebugAllocator(.{}).init; //获得分配器实例 const dgpa = gpa.allocator(); // 延时销毁 defer _ = gpa.deinit();"},{"id":2,"href":"/Programming-Notes/docs/notes/zig/","title":"Zig","section":"Introduction","content":"纪录#\r"}]