[{"id":0,"href":"/Programming-Notes/docs/notes/","title":"Introduction","section":"Docs","content":"这是我的第一篇文章#\r"},{"id":1,"href":"/Programming-Notes/docs/notes/zig/zig-grammar/","title":"Zig Grammar","section":"Zig","content":"zig 语法#\r流程控制#\rif#\rif可用来解包可选类型(?) 与 错误类型(!)\nconst optional:?i32 = null; if (optional) |number:i32| { //something todo } const error: anyerror!i32 = 0; if (error) |number:i32| { //something todo }高级类型#\r指针#\r单项指针#\r单项指针指向单个元素。\n单项指针的类型为 *T，其中 T 是所指向的数据类型。解引用操作使用 ptr.*。\n// 代码来自 zig 语言圣经 const print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { var integer: i16 = 666; const ptr = \u0026amp;integer; ptr.* = ptr.* + 1; print(\u0026#34;{}\\n\u0026#34;, .{integer}); }多项指针#\r多项指针指向一个或多个连续的元素，但其数量在编译期是未知的。 TIP\n多项指针的类型为 [*]T，其中 T 是所指向的数据类型，且 T 的大小必须是明确的（这意味着它不能是 anyopaque 或其他不透明类型）\nconst print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { const array = [_]i32{ 1, 2, 3, 4 }; const ptr: [*]const i32 = \u0026amp;array; print(\u0026#34;第一个元素：{}\\n\u0026#34;, .{ptr[0]}); }多个指针的区别#\r[4] const u8 // 该类型表示一个长度为4的数组，里面的类型 [] const u8 // 这表示是一个 内部类型为 const u8 的切片 *[4] const u8 // 表示一个指针，该指针的地址存储一个长度为4，元素为const u8的数组 *[] const u8 //这表示指针地址存储着一个切片 [*] const u8 // 表示一个多项指针 元素为const u8 但是长度未知切片与数组#\r切片#\r切片本质上是一个胖指针，内部有一个[*] T的多项指针与切片长度。\nconst array: [_] i32 = [_]i32{1,2,3,4}; const slice:[] i32 = array[0..4];联合类型#\runion与tag union#\runion { int:i32, float:f32 };union的缺陷是他不知道自己存储的是什么类型的数据。而tag union就是来解决这个问题的。\nunion(enum) { a:i32, b:f32, };opaque 透明类型#\rNOTE\n几乎用不到的类型，这通常用于与 C 代码交互时，确保类型安全，尤其是在 C 代码没有公开结构体细节的情况下。\nconst wat = opauqe {};与C交互#\r引入C头文件#\rconst c = @import({ @cDefine(\u0026#34;_NO_CRT_STDIN_INLINE\u0026#34;,\u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); })引入 vcpkg#\r声明C函数#\r// 声明一个C的外部函数 extern \u0026#34;C\u0026#34; fn add (x:i32,y:i32) i32; // 导出一个函数给c export fn add(x:i32,y:i32) callconv(.c) i32 {};内存管理#\r以DebugAllocator为例.\n// 获取DebugAllocator实例 var gpa = std.heap.DebugAllocator(.{}).init; //获得分配器实例 const dgpa = gpa.allocator(); // 延时销毁 defer _ = gpa.deinit();"},{"id":2,"href":"/Programming-Notes/docs/notes/zig/","title":"Zig","section":"Introduction","content":"纪录#\r"},{"id":3,"href":"/Programming-Notes/docs/notes/python/itertools/","title":"Itertools","section":"Python","content":"# Python itertools 模块方法介绍#\ritertools 模块提供了一系列用于高效循环的迭代器函数，以下是主要方法的简单介绍：\n无限迭代器#\rcount(start=0, step=1)#\rNOTE\n从 start 开始，以 step 为步长无限计数\ncount(10) → 10, 11, 12, 13, ...cycle(iterable)#\rNOTE\n无限重复迭代器中的元素\ncycle(\u0026#39;ABCD\u0026#39;) → A B C D A B C D ...repeat(object[, times])#\rNOTE\n重复对象指定次数或无限重复\nrepeat(10, 3) → 10, 10, 10有限迭代器#\raccumulate(iterable[, func])#\rNOTE\n返回累积值（默认求和）\naccumulate([1,2,3,4,5]) → 1, 3, 6, 10, 15chain(*iterables)#\rNOTE\n将多个迭代器连接成一个\nchain(\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;) → A B C D E Fchain.from_iterable(iterable)#\rNOTE\n从可迭代对象中链式连接\nchain.from_iterable([\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;]) → A B C D E Fcompress(data, selectors)#\rNOTE\n根据选择器筛选数据\ncompress(\u0026#39;ABCDEF\u0026#39;, [1,0,1,0,1,1]) → A C E Fdropwhile(predicate, iterable)#\rNOTE\n当 predicate 为真时丢弃元素，然后返回剩余所有\ndropwhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) → 6, 4, 1filterfalse(predicate, iterable)#\rNOTE\n返回 predicate 为假的元素\nfilterfalse(lambda x: x%2, range(10)) → 0, 2, 4, 6, 8groupby(iterable, key=None)#\rNOTE\n按键分组相邻的重复元素\n[k for k, g in groupby(\u0026#39;AAAABBBCCDAABBB\u0026#39;)] → A B C D A Bislice(iterable, stop) / islice(iterable, start, stop[, step])#\rNOTE\n对迭代器进行切片\nislice(\u0026#39;ABCDEFG\u0026#39;, 2, None) → C D E F Gstarmap(function, iterable)#\rNOTE\n将参数从迭代器中解包后应用函数\nstarmap(pow, [(2,5), (3,2), (10,3)]) → 32, 9, 1000takewhile(predicate, iterable)#\rNOTE\n当 predicate 为真时获取元素\ntakewhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) → 1, 4tee(iterable, n=2)#\rNOTE\n将一个迭代器拆分为 n 个独立的迭代器\na, b = tee(range(5))zip_longest(*iterables, fillvalue=None)#\rNOTE\n类似于 zip，但以最长迭代器为准，用 fillvalue 填充\nzip_longest(\u0026#39;ABCD\u0026#39;, \u0026#39;xy\u0026#39;, fillvalue=\u0026#39;-\u0026#39;) → Ax By C- D-组合迭代器#\rproduct(*iterables, repeat=1)#\rNOTE\n计算笛卡尔积\nproduct(\u0026#39;AB\u0026#39;, repeat=2) → AA AB BA BBpermutations(iterable, r=None)#\rNOTE\n返回长度为 r 的所有排列\npermutations(\u0026#39;ABCD\u0026#39;, 2) → AB AC AD BA BC BD CA CB CD DA DB DCcombinations(iterable, r)#\rNOTE\n返回长度为 r 的所有组合（按输入顺序）\ncombinations(\u0026#39;ABCD\u0026#39;, 2) → AB AC AD BC BD CDcombinations_with_replacement(iterable, r)#\rNOTE\n返回包含重复元素的组合\ncombinations_with_replacement(\u0026#39;ABC\u0026#39;, 2) → AA AB AC BB BC CC#\r#\r"}]