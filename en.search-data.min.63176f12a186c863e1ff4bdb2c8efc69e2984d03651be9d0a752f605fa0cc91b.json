[{"id":0,"href":"/Programming-Notes/docs/notes/","title":"Introduction","section":"Docs","content":"这是我的第一篇文章#\r"},{"id":1,"href":"/Programming-Notes/docs/notes/zig/zig-grammar/","title":"Zig Grammar","section":"Zig","content":"zig 语法#\r流程控制#\rif#\rif可用来解包可选类型(?) 与 错误类型(!)\nconst optional:?i32 = null; if (optional) |number:i32| { //something todo } const error: anyerror!i32 = 0; if (error) |number:i32| { //something todo }高级类型#\r指针#\r单项指针#\r单项指针指向单个元素。\n单项指针的类型为 *T，其中 T 是所指向的数据类型。解引用操作使用 ptr.*。\n// 代码来自 zig 语言圣经 const print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { var integer: i16 = 666; const ptr = \u0026amp;integer; ptr.* = ptr.* + 1; print(\u0026#34;{}\\n\u0026#34;, .{integer}); }多项指针#\r多项指针指向一个或多个连续的元素，但其数量在编译期是未知的。 TIP\n多项指针的类型为 [*]T，其中 T 是所指向的数据类型，且 T 的大小必须是明确的（这意味着它不能是 anyopaque 或其他不透明类型）\nconst print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { const array = [_]i32{ 1, 2, 3, 4 }; const ptr: [*]const i32 = \u0026amp;array; print(\u0026#34;第一个元素：{}\\n\u0026#34;, .{ptr[0]}); }多个指针的区别#\r[4] const u8 // 该类型表示一个长度为4的数组，里面的类型 [] const u8 // 这表示是一个 内部类型为 const u8 的切片 *[4] const u8 // 表示一个指针，该指针的地址存储一个长度为4，元素为const u8的数组 *[] const u8 //这表示指针地址存储着一个切片 [*] const u8 // 表示一个多项指针 元素为const u8 但是长度未知切片与数组#\r切片#\r切片本质上是一个胖指针，内部有一个[*] T的多项指针与切片长度。\nconst array: [_] i32 = [_]i32{1,2,3,4}; const slice:[] i32 = array[0..4];联合类型#\runion与tag union#\runion { int:i32, float:f32 };union的缺陷是他不知道自己存储的是什么类型的数据。而tag union就是来解决这个问题的。\nunion(enum) { a:i32, b:f32, };opaque 透明类型#\rNOTE\n几乎用不到的类型，这通常用于与 C 代码交互时，确保类型安全，尤其是在 C 代码没有公开结构体细节的情况下。\nconst wat = opauqe {};与C交互#\r引入C头文件#\rconst c = @import({ @cDefine(\u0026#34;_NO_CRT_STDIN_INLINE\u0026#34;,\u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); })引入 vcpkg#\r声明C函数#\r// 声明一个C的外部函数 extern \u0026#34;C\u0026#34; fn add (x:i32,y:i32) i32; // 导出一个函数给c export fn add(x:i32,y:i32) callconv(.c) i32 {};内存管理#\r以DebugAllocator为例.\n// 获取DebugAllocator实例 var gpa = std.heap.DebugAllocator(.{}).init; //获得分配器实例 const dgpa = gpa.allocator(); // 延时销毁 defer _ = gpa.deinit();"},{"id":2,"href":"/Programming-Notes/docs/notes/python/","title":"Python","section":"Introduction","content":"Python配置#\rLSP#\rBasedpyright#\r目前使用相当舒服的Python LSP 为 basedpyright 它提供类型检查、inlayhint等，可以通过pyrightconfig.json配置。\nruff#\r与Basedpyright相比，ruff 提供了代码检查的功能。\n虚拟环境#\ruv#\rRust 编写的 python虚拟环境管理工具其使用方法与Rust的cargo类似。\n"},{"id":3,"href":"/Programming-Notes/docs/notes/zig/","title":"Zig","section":"Introduction","content":"Zig#\r面向系统编程的编程语言其最终目的是为了代替C语言。\n"},{"id":4,"href":"/Programming-Notes/docs/notes/python/itertools/","title":"Itertools","section":"Python","content":"Python itertools 模块方法介绍#\ritertools 模块提供了一系列用于高效循环的迭代器函数，以下是主要方法的简单介绍：\n无限迭代器#\rcount(start=0, step=1)#\rNOTE\n从 start 开始，以 step 为步长无限计数\ncount(10) → 10, 11, 12, 13, ...cycle(iterable)#\rNOTE\n无限重复迭代器中的元素\ncycle(\u0026#39;ABCD\u0026#39;) → A B C D A B C D ...repeat(object[, times])#\rNOTE\n重复对象指定次数或无限重复\nrepeat(10, 3) → 10, 10, 10有限迭代器#\raccumulate(iterable[, func])#\rNOTE\n返回累积值（默认求和）\naccumulate([1,2,3,4,5]) → 1, 3, 6, 10, 15chain(*iterables)#\rNOTE\n将多个迭代器连接成一个\nchain(\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;) → A B C D E Fchain.from_iterable(iterable)#\rNOTE\n从可迭代对象中链式连接\nchain.from_iterable([\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;]) → A B C D E Fcompress(data, selectors)#\rNOTE\n根据选择器筛选数据\ncompress(\u0026#39;ABCDEF\u0026#39;, [1,0,1,0,1,1]) → A C E Fdropwhile(predicate, iterable)#\rNOTE\n当 predicate 为真时丢弃元素，然后返回剩余所有\ndropwhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) → 6, 4, 1filterfalse(predicate, iterable)#\rNOTE\n返回 predicate 为假的元素\nfilterfalse(lambda x: x%2, range(10)) → 0, 2, 4, 6, 8groupby(iterable, key=None)#\rNOTE\n按键分组相邻的重复元素\n[k for k, g in groupby(\u0026#39;AAAABBBCCDAABBB\u0026#39;)] → A B C D A Bislice(iterable, stop) / islice(iterable, start, stop[, step])#\rNOTE\n对迭代器进行切片\nislice(\u0026#39;ABCDEFG\u0026#39;, 2, None) → C D E F Gstarmap(function, iterable)#\rNOTE\n将参数从迭代器中解包后应用函数\nstarmap(pow, [(2,5), (3,2), (10,3)]) → 32, 9, 1000takewhile(predicate, iterable)#\rNOTE\n当 predicate 为真时获取元素\ntakewhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) → 1, 4tee(iterable, n=2)#\rNOTE\n将一个迭代器拆分为 n 个独立的迭代器\na, b = tee(range(5))zip_longest(*iterables, fillvalue=None)#\rNOTE\n类似于 zip，但以最长迭代器为准，用 fillvalue 填充\nzip_longest(\u0026#39;ABCD\u0026#39;, \u0026#39;xy\u0026#39;, fillvalue=\u0026#39;-\u0026#39;) → Ax By C- D-组合迭代器#\rproduct(*iterables, repeat=1)#\rNOTE\n计算笛卡尔积\nproduct(\u0026#39;AB\u0026#39;, repeat=2) → AA AB BA BBpermutations(iterable, r=None)#\rNOTE\n返回长度为 r 的所有排列\npermutations(\u0026#39;ABCD\u0026#39;, 2) → AB AC AD BA BC BD CA CB CD DA DB DCcombinations(iterable, r)#\rNOTE\n返回长度为 r 的所有组合（按输入顺序）\ncombinations(\u0026#39;ABCD\u0026#39;, 2) → AB AC AD BC BD CDcombinations_with_replacement(iterable, r)#\rNOTE\n返回包含重复元素的组合\ncombinations_with_replacement(\u0026#39;ABC\u0026#39;, 2) → AA AB AC BB BC CC#\r#\r"},{"id":5,"href":"/Programming-Notes/docs/notes/python/modern_python/","title":"Modern Python","section":"Python","content":"python笔记#\rpython 效率提升#\r链式比较#\r# 传统写法 if x \u0026lt; 20 and x \u0026lt; 10 # 链式比较 if 20 \u0026gt; x \u0026gt; 10表达式#\r# 列表表达式 my_list: list[int] = [expr(x) for x in chain(range(1...5),range(1..5)] # 集合表达式 my_set: set[str] = {expr(x) for x in my_list} # 字典表达式 my_dict: dict[str,int] = {expr(k):expr(v) for k,v in some_dict}chain 函数提高内存效率#\r# 惰性求值 chain(iter1,iter2)装饰器#\r# @wrap 就是装饰器 @wrap def add(x:int,y:int) -\u0026gt; int: 装饰器可以简单理解为在运行函数之前执行与函数执行结束之后执行一些特定的操作。\n装饰器也是函数。\n被装饰器修饰的函数将会在装饰器内部执行。\n自定义装饰器#\rfrom typing import Callable,Any from time import perf_counter,sleep # 计时装饰器 def time(func:Callable) -\u0026gt; Callable: def wrapper(*args,**kargs) -\u0026gt; Any: print(f\u0026#39;Timing \u0026#34;{func.__name__}\u0026#34;...\u0026#39;) start:float = perf_counter() result:Any = func(*args,**kargs) end:float = perf_counter() print(f\u0026#39;\u0026#34;{func.__name__}\u0026#34; took: {end - start: .4f}s\u0026#39;) return result return wrapper # 函数式写法 def time(func:Callable) -\u0026gt; Callable: @wraps(func) def wrapper(*args,**kargs) -\u0026gt; Any:上下文#\rwith 语法 使用提供的上下文 (@cotextmanager)#\rpython 的builtin库 内置的contextlib中contextmanager装饰器可以将生成器变为具有上下文的函数。\nfrom contextlib import contextmanager @contextmanager def file_handle() -\u0026gt; Geneator[File,None,None]: # 函数逻辑也可使用类来提供一个上下文需要类的实现__enter__与__exit__函数\nclass File: def __enter__(self): def __exit__(self):面向对象#\r__furture__#\r用于在类或枚举中使用自己的类型\nfrom __future__ import annotations枚举#\rWARNING 通常枚举不可以使用@dataclass装饰器。但是在运行时不会报错。\n# lsp 会提示这样使用是错误的 @dataclass class Type(Enum): # 正确用法 class Type(Enum): Some = None实例方法·类方法·静态方法#\r类方法是针对类的，实例方法是针对实例的，静态方法是针对类和实例的。\n类方法常用于提供额外的构造对象的方式，作为__init__方法的补充。\n# 静态方法 @staticmethod # 类方法 @classmethod函数式编程#\rpymonad#\r函数组合#\rCompose#\r使用Compose的函数必须有一个参数，可以用None代替。\nfrom pymonad.reader import Compose def add(placeHolder = None) -\u0026gt; int: return 3 Compose(add).then(mul)Pipe#\r"}]