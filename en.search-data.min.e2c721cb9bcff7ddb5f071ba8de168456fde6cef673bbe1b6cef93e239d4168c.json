[{"id":0,"href":"/Programming-Notes/docs/notes/","title":"Introduction","section":"Docs","content":"è¿™æ˜¯æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« #\r"},{"id":1,"href":"/Programming-Notes/docs/notes/zig/zig-grammar/","title":"Zig Grammar","section":"Zig","content":"zig è¯­æ³•#\ræµç¨‹æ§åˆ¶#\rif#\rifå¯ç”¨æ¥è§£åŒ…å¯é€‰ç±»å‹(?) ä¸ é”™è¯¯ç±»å‹(!)\nconst optional:?i32 = null; if (optional) |number:i32| { //something todo } const error: anyerror!i32 = 0; if (error) |number:i32| { //something todo }é«˜çº§ç±»å‹#\ræŒ‡é’ˆ#\rå•é¡¹æŒ‡é’ˆ#\rå•é¡¹æŒ‡é’ˆæŒ‡å‘å•ä¸ªå…ƒç´ ã€‚\nå•é¡¹æŒ‡é’ˆçš„ç±»å‹ä¸ºÂ *Tï¼Œå…¶ä¸­Â TÂ æ˜¯æ‰€æŒ‡å‘çš„æ•°æ®ç±»å‹ã€‚è§£å¼•ç”¨æ“ä½œä½¿ç”¨Â ptr.*ã€‚\n// ä»£ç æ¥è‡ª zig è¯­è¨€åœ£ç» const print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { var integer: i16 = 666; const ptr = \u0026amp;integer; ptr.* = ptr.* + 1; print(\u0026#34;{}\\n\u0026#34;, .{integer}); }å¤šé¡¹æŒ‡é’ˆ#\rå¤šé¡¹æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªæˆ–å¤šä¸ªè¿ç»­çš„å…ƒç´ ï¼Œä½†å…¶æ•°é‡åœ¨ç¼–è¯‘æœŸæ˜¯æœªçŸ¥çš„ã€‚ TIP\nå¤šé¡¹æŒ‡é’ˆçš„ç±»å‹ä¸ºÂ [*]Tï¼Œå…¶ä¸­Â TÂ æ˜¯æ‰€æŒ‡å‘çš„æ•°æ®ç±»å‹ï¼Œä¸”Â TÂ çš„å¤§å°å¿…é¡»æ˜¯æ˜ç¡®çš„ï¼ˆè¿™æ„å‘³ç€å®ƒä¸èƒ½æ˜¯Â anyopaqueÂ æˆ–å…¶ä»–ä¸é€æ˜ç±»å‹ï¼‰\nconst print = @import(\u0026#34;std\u0026#34;).debug.print; pub fn main() !void { const array = [_]i32{ 1, 2, 3, 4 }; const ptr: [*]const i32 = \u0026amp;array; print(\u0026#34;ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š{}\\n\u0026#34;, .{ptr[0]}); }å¤šä¸ªæŒ‡é’ˆçš„åŒºåˆ«#\r[4] const u8 // è¯¥ç±»å‹è¡¨ç¤ºä¸€ä¸ªé•¿åº¦ä¸º4çš„æ•°ç»„ï¼Œé‡Œé¢çš„ç±»å‹ [] const u8 // è¿™è¡¨ç¤ºæ˜¯ä¸€ä¸ª å†…éƒ¨ç±»å‹ä¸º const u8 çš„åˆ‡ç‰‡ *[4] const u8 // è¡¨ç¤ºä¸€ä¸ªæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆçš„åœ°å€å­˜å‚¨ä¸€ä¸ªé•¿åº¦ä¸º4ï¼Œå…ƒç´ ä¸ºconst u8çš„æ•°ç»„ *[] const u8 //è¿™è¡¨ç¤ºæŒ‡é’ˆåœ°å€å­˜å‚¨ç€ä¸€ä¸ªåˆ‡ç‰‡ [*] const u8 // è¡¨ç¤ºä¸€ä¸ªå¤šé¡¹æŒ‡é’ˆ å…ƒç´ ä¸ºconst u8 ä½†æ˜¯é•¿åº¦æœªçŸ¥åˆ‡ç‰‡ä¸æ•°ç»„#\råˆ‡ç‰‡#\råˆ‡ç‰‡æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªèƒ–æŒ‡é’ˆï¼Œå†…éƒ¨æœ‰ä¸€ä¸ª[*] Tçš„å¤šé¡¹æŒ‡é’ˆä¸åˆ‡ç‰‡é•¿åº¦ã€‚\nconst array: [_] i32 = [_]i32{1,2,3,4}; const slice:[] i32 = array[0..4];è”åˆç±»å‹#\runionä¸tag union#\runion { int:i32, float:f32 };unionçš„ç¼ºé™·æ˜¯ä»–ä¸çŸ¥é“è‡ªå·±å­˜å‚¨çš„æ˜¯ä»€ä¹ˆç±»å‹çš„æ•°æ®ã€‚è€Œtag unionå°±æ˜¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜çš„ã€‚\nunion(enum) { a:i32, b:f32, };opaque é€æ˜ç±»å‹#\rNOTE\nå‡ ä¹ç”¨ä¸åˆ°çš„ç±»å‹ï¼Œè¿™é€šå¸¸ç”¨äºä¸ C ä»£ç äº¤äº’æ—¶ï¼Œç¡®ä¿ç±»å‹å®‰å…¨ï¼Œå°¤å…¶æ˜¯åœ¨ C ä»£ç æ²¡æœ‰å…¬å¼€ç»“æ„ä½“ç»†èŠ‚çš„æƒ…å†µä¸‹ã€‚\nconst wat = opauqe {};ä¸Cäº¤äº’#\rå¼•å…¥Cå¤´æ–‡ä»¶#\rconst c = @import({ @cDefine(\u0026#34;_NO_CRT_STDIN_INLINE\u0026#34;,\u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); })å¼•å…¥ vcpkg#\rå£°æ˜Cå‡½æ•°#\r// å£°æ˜ä¸€ä¸ªCçš„å¤–éƒ¨å‡½æ•° extern \u0026#34;C\u0026#34; fn add (x:i32,y:i32) i32; // å¯¼å‡ºä¸€ä¸ªå‡½æ•°ç»™c export fn add(x:i32,y:i32) callconv(.c) i32 {};å†…å­˜ç®¡ç†#\rä»¥DebugAllocatorä¸ºä¾‹.\n// è·å–DebugAllocatorå®ä¾‹ var gpa = std.heap.DebugAllocator(.{}).init; //è·å¾—åˆ†é…å™¨å®ä¾‹ const dgpa = gpa.allocator(); // å»¶æ—¶é”€æ¯ defer _ = gpa.deinit();"},{"id":2,"href":"/Programming-Notes/docs/notes/python/","title":"Python","section":"Introduction","content":"Pythoné…ç½®#\rLSP#\rBasedpyright#\rç›®å‰ä½¿ç”¨ç›¸å½“èˆ’æœçš„Python LSP ä¸º basedpyright å®ƒæä¾›ç±»å‹æ£€æŸ¥ã€inlayhintç­‰ï¼Œå¯ä»¥é€šè¿‡pyrightconfig.jsoné…ç½®ã€‚\nruff#\rä¸Basedpyrightç›¸æ¯”ï¼Œruff æä¾›äº†ä»£ç æ£€æŸ¥çš„åŠŸèƒ½ã€‚\nè™šæ‹Ÿç¯å¢ƒ#\ruv#\rRust ç¼–å†™çš„ pythonè™šæ‹Ÿç¯å¢ƒç®¡ç†å·¥å…·å…¶ä½¿ç”¨æ–¹æ³•ä¸Rustçš„cargoç±»ä¼¼ã€‚\n"},{"id":3,"href":"/Programming-Notes/docs/notes/zig/","title":"Zig","section":"Introduction","content":"Zig#\ré¢å‘ç³»ç»Ÿç¼–ç¨‹çš„ç¼–ç¨‹è¯­è¨€å…¶æœ€ç»ˆç›®çš„æ˜¯ä¸ºäº†ä»£æ›¿Cè¯­è¨€ã€‚\n"},{"id":4,"href":"/Programming-Notes/docs/notes/rust/","title":"Rust","section":"Introduction","content":"Rust è®°å½•#\rè®°å½•Rustä¸­å¸¸ç”¨çš„crateã€Rustæ–°å¢è¯­æ³•ä¸unsafe Rustã€‚\n"},{"id":5,"href":"/Programming-Notes/docs/notes/rust/crate/","title":"Rust Crate","section":"Rust","content":"Rust Crate#\rIMPORTANT\nè®°å½•Rustä¸­å¸¸ç”¨çš„crateä¸å…¶è¯­æ³•ã€‚\n"},{"id":6,"href":"/Programming-Notes/docs/notes/python/functional_py/","title":"Functional Py","section":"Python","content":"Pytoolz#\rA functional standard library for Python.\næ ¸å¿ƒæ¨¡å—#\rItertoolz - è¿­ä»£å·¥å…·#\rå¤„ç†åºåˆ—å’Œè¿­ä»£å™¨çš„å‡½æ•°ï¼š\nå‡½æ•° è¯´æ˜ accumulate(binop, seq[, initial]) å¯¹åºåˆ—é‡å¤åº”ç”¨äºŒå…ƒå‡½æ•°ï¼Œç´¯ç§¯ç»“æœ concat(seqs) è¿æ¥é›¶ä¸ªæˆ–å¤šä¸ªå¯è¿­ä»£å¯¹è±¡ concatv(*seqs) concatçš„å¯å˜å‚æ•°ç‰ˆæœ¬ cons(el, seq) å°†å…ƒç´ æ·»åŠ åˆ°åºåˆ—å¼€å¤´ count(seq) è®¡ç®—åºåˆ—ä¸­çš„é¡¹æ•° drop(n, seq) è¿”å›è·³è¿‡å‰nä¸ªå…ƒç´ åçš„åºåˆ— first(seq) åºåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´  frequencies(seq) æ‰¾å‡ºåºåˆ—ä¸­æ¯ä¸ªå€¼å‡ºç°çš„æ¬¡æ•° get(ind, seq[, default]) è·å–åºåˆ—æˆ–å­—å…¸ä¸­çš„å…ƒç´  groupby(key, seq) æŒ‰é”®å‡½æ•°å¯¹é›†åˆè¿›è¡Œåˆ†ç»„ interleave(seqs) äº¤é”™ä¸€ä¸ªåºåˆ—çš„åºåˆ— interpose(el, seq) åœ¨åºåˆ—çš„æ¯å¯¹å…ƒç´ ä¹‹é—´å¼•å…¥å…ƒç´  isdistinct(seq) æ£€æŸ¥åºåˆ—ä¸­çš„æ‰€æœ‰å€¼æ˜¯å¦ä¸åŒ isiterable(x) æ£€æŸ¥xæ˜¯å¦å¯è¿­ä»£ iterate(func, x) é‡å¤å¯¹åŸå§‹è¾“å…¥åº”ç”¨å‡½æ•° join(leftkey, leftseq, rightkey, rightseq[, ...]) åœ¨å…¬å…±å±æ€§ä¸Šè¿æ¥ä¸¤ä¸ªåºåˆ— last(seq) åºåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´  mapcat(func, seqs) å¯¹seqsä¸­çš„æ¯ä¸ªåºåˆ—åº”ç”¨funcï¼Œè¿æ¥ç»“æœ merge_sorted(*seqs, **kwargs) åˆå¹¶å’Œæ’åºå·²æ’åºé›†åˆçš„é›†åˆ nth(n, seq) åºåˆ—çš„ç¬¬nä¸ªå…ƒç´  partition(n, seq[, pad]) å°†åºåˆ—åˆ†åŒºä¸ºé•¿åº¦ä¸ºnçš„å…ƒç»„ partition_all(n, seq) å°†æ‰€æœ‰å…ƒç´ åˆ†åŒºä¸ºæœ€å¤šnä¸ªå…ƒç´ çš„å…ƒç»„ peek(seq) æ£€ç´¢åºåˆ—çš„ä¸‹ä¸€ä¸ªå…ƒç´  peekn(n, seq) æ£€ç´¢åºåˆ—çš„ä¸‹nä¸ªå…ƒç´  pluck(ind, seqs[, default]) ä»åºåˆ—ä¸­çš„æ¯ä¸ªé¡¹æå–ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´  random_sample(prob, seq[, random_state]) ä»¥æ¦‚ç‡probä»åºåˆ—è¿”å›å…ƒç´  reduceby(key, binop, seq[, init]) æ‰§è¡ŒåŒæ—¶çš„groupbyå’Œreduction remove(predicate, seq) è¿”å›predicate(item)ä¸ºFalseçš„åºåˆ—é¡¹ second(seq) åºåˆ—çš„ç¬¬äºŒä¸ªå…ƒç´  sliding_window(n, seq) é‡å å­åºåˆ—çš„åºåˆ— tail(n, seq) åºåˆ—çš„æœ€ånä¸ªå…ƒç´  take(n, seq) åºåˆ—çš„å‰nä¸ªå…ƒç´  take_nth(n, seq) seqä¸­çš„æ¯ç¬¬nä¸ªé¡¹ topk(k, seq[, key]) æ‰¾å‡ºåºåˆ—çš„kä¸ªæœ€å¤§å…ƒç´  unique(seq[, key]) ä»…è¿”å›åºåˆ—çš„å”¯ä¸€å…ƒç´  Functoolz - å‡½æ•°å·¥å…·#\rå‡½æ•°ç»„åˆå’Œæ“ä½œï¼š\nå‡½æ•° è¯´æ˜ apply(*func_and_args, **kwargs) åº”ç”¨å‡½æ•°å¹¶è¿”å›ç»“æœ complement(func) å°†è°“è¯å‡½æ•°è½¬æ¢ä¸ºå…¶é€»è¾‘è¡¥é›† compose(*funcs) ç»„åˆå‡½æ•°ä»¥ä¸²è”æ“ä½œ compose_left(*funcs) ä»å·¦åˆ°å³ç»„åˆå‡½æ•° curry(*args, **kwargs) å¯¹å¯è°ƒç”¨å‡½æ•°è¿›è¡ŒæŸ¯é‡ŒåŒ– do(func, x) åœ¨xä¸Šè¿è¡Œfuncï¼Œè¿”å›x excepts(exc, func[, handler]) æ•è·å¼‚å¸¸å¹¶åˆ†æ´¾åˆ°å¤„ç†ç¨‹åºçš„åŒ…è£…å™¨ flip([func, a, b]) è°ƒç”¨å‡½æ•°æ—¶ç¿»è½¬å‚æ•° identity(x) æ’ç­‰å‡½æ•° juxt(*funcs) åˆ›å»ºä¸€ä¸ªç”¨ç›¸åŒå‚æ•°è°ƒç”¨å¤šä¸ªå‡½æ•°çš„å‡½æ•° memoize([func, cache, key]) ç¼“å­˜å‡½æ•°ç»“æœä»¥åŠ å¿«æœªæ¥è¯„ä¼° pipe(data, *funcs) é€šè¿‡ä¸€ç³»åˆ—å‡½æ•°ç®¡é“ä¼ é€’å€¼ thread_first(val, *forms) é€šè¿‡ä¸€ç³»åˆ—å‡½æ•°/å½¢å¼çº¿ç¨‹åŒ–å€¼ thread_last(val, *forms) é€šè¿‡ä¸€ç³»åˆ—å‡½æ•°/å½¢å¼çº¿ç¨‹åŒ–å€¼ Dicttoolz - å­—å…¸å·¥å…·#\rå­—å…¸æ“ä½œå‡½æ•°ï¼š\nå‡½æ•° è¯´æ˜ assoc(d, key, value[, factory]) è¿”å›å¸¦æœ‰æ–°é”®å€¼å¯¹çš„æ–°å­—å…¸ assoc_in(d, keys, value[, factory]) è¿”å›å¸¦æœ‰æ–°çš„ã€å¯èƒ½åµŒå¥—çš„é”®å€¼å¯¹çš„æ–°å­—å…¸ dissoc(d, *keys, **kwargs) è¿”å›åˆ é™¤ç»™å®šé”®çš„æ–°å­—å…¸ get_in(keys, coll[, default, no_default]) è¿”å›coll[i0][i1]\u0026hellip;[iX] itemfilter(predicate, d[, factory]) æŒ‰é¡¹è¿‡æ»¤å­—å…¸ä¸­çš„é¡¹ itemmap(func, d[, factory]) å¯¹å­—å…¸çš„é¡¹åº”ç”¨å‡½æ•° keyfilter(predicate, d[, factory]) æŒ‰é”®è¿‡æ»¤å­—å…¸ä¸­çš„é¡¹ keymap(func, d[, factory]) å¯¹å­—å…¸çš„é”®åº”ç”¨å‡½æ•° merge(*dicts, **kwargs) åˆå¹¶å­—å…¸é›†åˆ merge_with(func, *dicts, **kwargs) åˆå¹¶å­—å…¸å¹¶å¯¹åˆå¹¶çš„å€¼åº”ç”¨å‡½æ•° update_in(d, keys, func[, default, factory]) æ›´æ–°åµŒå¥—å­—å…¸å€¼ åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹#\rfrom toolz import * # Itertoolz ç¤ºä¾‹ take(3, [1, 2, 3, 4, 5]) # (1, 2, 3) drop(2, [1, 2, 3, 4, 5]) # (3, 4, 5) first([1, 2, 3]) # 1 last([1, 2, 3]) # 3 # åˆ†ç»„ groupby(lambda x: x % 2, [1, 2, 3, 4, 5]) # {0: [2, 4], 1: [1, 3, 5]} # å‡½æ•°ç»„åˆ add1 = lambda x: x + 1 mul2 = lambda x: x * 2 f = compose(add1, mul2) f(3) # add1(mul2(3)) = 7 # ç®¡é“ pipe(3, mul2, add1) # 7 # å­—å…¸æ“ä½œ d = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} assoc(d, \u0026#39;c\u0026#39;, 3) # {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3}å¸¸ç”¨å‡½æ•° excepts#\r# ç¤ºä¾‹1ï¼šåŸºæœ¬å¼‚å¸¸æ•è· def divide(x, y): return x / y # åˆ›å»ºä¸€ä¸ªå®‰å…¨çš„é™¤æ³•å‡½æ•°ï¼Œæ•è·ZeroDivisionError safe_divide = excepts(ZeroDivisionError, divide) safe_divide(10, 2) # 5.0 safe_divide(10, 0) # Noneï¼ˆå¼‚å¸¸è¢«æ•è·ï¼‰ # ç¤ºä¾‹2ï¼šè‡ªå®šä¹‰å¼‚å¸¸å¤„ç†ç¨‹åº def handle_error(exc): return f\u0026#34;Error: {exc}\u0026#34; safe_divide_with_handler = excepts(ZeroDivisionError, divide, handle_error) safe_divide_with_handler(10, 2) # 5.0 safe_divide_with_handler(10, 0) # \u0026#34;Error: division by zero\u0026#34;"},{"id":7,"href":"/Programming-Notes/docs/notes/python/itertools/","title":"Itertools","section":"Python","content":"Python itertools æ¨¡å—æ–¹æ³•ä»‹ç»#\ritertools æ¨¡å—æä¾›äº†ä¸€ç³»åˆ—ç”¨äºé«˜æ•ˆå¾ªç¯çš„è¿­ä»£å™¨å‡½æ•°ï¼Œä»¥ä¸‹æ˜¯ä¸»è¦æ–¹æ³•çš„ç®€å•ä»‹ç»ï¼š\næ— é™è¿­ä»£å™¨#\rcount(start=0, step=1)#\rNOTE\nä» start å¼€å§‹ï¼Œä»¥ step ä¸ºæ­¥é•¿æ— é™è®¡æ•°\ncount(10) â†’ 10, 11, 12, 13, ...cycle(iterable)#\rNOTE\næ— é™é‡å¤è¿­ä»£å™¨ä¸­çš„å…ƒç´ \ncycle(\u0026#39;ABCD\u0026#39;) â†’ A B C D A B C D ...repeat(object[, times])#\rNOTE\né‡å¤å¯¹è±¡æŒ‡å®šæ¬¡æ•°æˆ–æ— é™é‡å¤\nrepeat(10, 3) â†’ 10, 10, 10æœ‰é™è¿­ä»£å™¨#\raccumulate(iterable[, func])#\rNOTE\nè¿”å›ç´¯ç§¯å€¼ï¼ˆé»˜è®¤æ±‚å’Œï¼‰\naccumulate([1,2,3,4,5]) â†’ 1, 3, 6, 10, 15chain(*iterables)#\rNOTE\nå°†å¤šä¸ªè¿­ä»£å™¨è¿æ¥æˆä¸€ä¸ª\nchain(\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;) â†’ A B C D E Fchain.from_iterable(iterable)#\rNOTE\nä»å¯è¿­ä»£å¯¹è±¡ä¸­é“¾å¼è¿æ¥\nchain.from_iterable([\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;]) â†’ A B C D E Fcompress(data, selectors)#\rNOTE\næ ¹æ®é€‰æ‹©å™¨ç­›é€‰æ•°æ®\ncompress(\u0026#39;ABCDEF\u0026#39;, [1,0,1,0,1,1]) â†’ A C E Fdropwhile(predicate, iterable)#\rNOTE\nå½“ predicate ä¸ºçœŸæ—¶ä¸¢å¼ƒå…ƒç´ ï¼Œç„¶åè¿”å›å‰©ä½™æ‰€æœ‰\ndropwhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) â†’ 6, 4, 1filterfalse(predicate, iterable)#\rNOTE\nè¿”å› predicate ä¸ºå‡çš„å…ƒç´ \nfilterfalse(lambda x: x%2, range(10)) â†’ 0, 2, 4, 6, 8groupby(iterable, key=None)#\rNOTE\næŒ‰é”®åˆ†ç»„ç›¸é‚»çš„é‡å¤å…ƒç´ \n[k for k, g in groupby(\u0026#39;AAAABBBCCDAABBB\u0026#39;)] â†’ A B C D A Bislice(iterable, stop) / islice(iterable, start, stop[, step])#\rNOTE\nå¯¹è¿­ä»£å™¨è¿›è¡Œåˆ‡ç‰‡\nislice(\u0026#39;ABCDEFG\u0026#39;, 2, None) â†’ C D E F Gstarmap(function, iterable)#\rNOTE\nå°†å‚æ•°ä»è¿­ä»£å™¨ä¸­è§£åŒ…ååº”ç”¨å‡½æ•°\nstarmap(pow, [(2,5), (3,2), (10,3)]) â†’ 32, 9, 1000takewhile(predicate, iterable)#\rNOTE\nå½“ predicate ä¸ºçœŸæ—¶è·å–å…ƒç´ \ntakewhile(lambda x: x\u0026lt;5, [1,4,6,4,1]) â†’ 1, 4tee(iterable, n=2)#\rNOTE\nå°†ä¸€ä¸ªè¿­ä»£å™¨æ‹†åˆ†ä¸º n ä¸ªç‹¬ç«‹çš„è¿­ä»£å™¨\na, b = tee(range(5))zip_longest(*iterables, fillvalue=None)#\rNOTE\nç±»ä¼¼äº zipï¼Œä½†ä»¥æœ€é•¿è¿­ä»£å™¨ä¸ºå‡†ï¼Œç”¨ fillvalue å¡«å……\nzip_longest(\u0026#39;ABCD\u0026#39;, \u0026#39;xy\u0026#39;, fillvalue=\u0026#39;-\u0026#39;) â†’ Ax By C- D-ç»„åˆè¿­ä»£å™¨#\rproduct(*iterables, repeat=1)#\rNOTE\nè®¡ç®—ç¬›å¡å°”ç§¯\nproduct(\u0026#39;AB\u0026#39;, repeat=2) â†’ AA AB BA BBpermutations(iterable, r=None)#\rNOTE\nè¿”å›é•¿åº¦ä¸º r çš„æ‰€æœ‰æ’åˆ—\npermutations(\u0026#39;ABCD\u0026#39;, 2) â†’ AB AC AD BA BC BD CA CB CD DA DB DCcombinations(iterable, r)#\rNOTE\nè¿”å›é•¿åº¦ä¸º r çš„æ‰€æœ‰ç»„åˆï¼ˆæŒ‰è¾“å…¥é¡ºåºï¼‰\ncombinations(\u0026#39;ABCD\u0026#39;, 2) â†’ AB AC AD BC BD CDcombinations_with_replacement(iterable, r)#\rNOTE\nè¿”å›åŒ…å«é‡å¤å…ƒç´ çš„ç»„åˆ\ncombinations_with_replacement(\u0026#39;ABC\u0026#39;, 2) â†’ AA AB AC BB BC CC#\r#\r"},{"id":8,"href":"/Programming-Notes/docs/notes/python/modern_python/","title":"Modern Python","section":"Python","content":"pythonç¬”è®°#\rpython æ•ˆç‡æå‡#\ré“¾å¼æ¯”è¾ƒ#\r# ä¼ ç»Ÿå†™æ³• if x \u0026lt; 20 and x \u0026lt; 10 # é“¾å¼æ¯”è¾ƒ if 20 \u0026gt; x \u0026gt; 10è¡¨è¾¾å¼#\r# åˆ—è¡¨è¡¨è¾¾å¼ my_list: list[int] = [expr(x) for x in chain(range(1...5),range(1..5)] # é›†åˆè¡¨è¾¾å¼ my_set: set[str] = {expr(x) for x in my_list} # å­—å…¸è¡¨è¾¾å¼ my_dict: dict[str,int] = {expr(k):expr(v) for k,v in some_dict}chain å‡½æ•°æé«˜å†…å­˜æ•ˆç‡#\r# æƒ°æ€§æ±‚å€¼ chain(iter1,iter2)è£…é¥°å™¨#\r# @wrap å°±æ˜¯è£…é¥°å™¨ @wrap def add(x:int,y:int) -\u0026gt; int: è£…é¥°å™¨å¯ä»¥ç®€å•ç†è§£ä¸ºåœ¨è¿è¡Œå‡½æ•°ä¹‹å‰æ‰§è¡Œä¸å‡½æ•°æ‰§è¡Œç»“æŸä¹‹åæ‰§è¡Œä¸€äº›ç‰¹å®šçš„æ“ä½œã€‚\nè£…é¥°å™¨ä¹Ÿæ˜¯å‡½æ•°ã€‚\nè¢«è£…é¥°å™¨ä¿®é¥°çš„å‡½æ•°å°†ä¼šåœ¨è£…é¥°å™¨å†…éƒ¨æ‰§è¡Œã€‚\nè‡ªå®šä¹‰è£…é¥°å™¨#\rfrom typing import Callable,Any from time import perf_counter,sleep # è®¡æ—¶è£…é¥°å™¨ def time(func:Callable) -\u0026gt; Callable: def wrapper(*args,**kargs) -\u0026gt; Any: print(f\u0026#39;Timing \u0026#34;{func.__name__}\u0026#34;...\u0026#39;) start:float = perf_counter() result:Any = func(*args,**kargs) end:float = perf_counter() print(f\u0026#39;\u0026#34;{func.__name__}\u0026#34; took: {end - start: .4f}s\u0026#39;) return result return wrapper # å‡½æ•°å¼å†™æ³• def time(func:Callable) -\u0026gt; Callable: @wraps(func) def wrapper(*args,**kargs) -\u0026gt; Any:ä¸Šä¸‹æ–‡#\rwith è¯­æ³• ä½¿ç”¨æä¾›çš„ä¸Šä¸‹æ–‡ (@cotextmanager)#\rpython çš„builtinåº“ å†…ç½®çš„contextlibä¸­contextmanagerè£…é¥°å™¨å¯ä»¥å°†ç”Ÿæˆå™¨å˜ä¸ºå…·æœ‰ä¸Šä¸‹æ–‡çš„å‡½æ•°ã€‚\nfrom contextlib import contextmanager @contextmanager def file_handle() -\u0026gt; Geneator[File,None,None]: # å‡½æ•°é€»è¾‘ä¹Ÿå¯ä½¿ç”¨ç±»æ¥æä¾›ä¸€ä¸ªä¸Šä¸‹æ–‡éœ€è¦ç±»çš„å®ç°__enter__ä¸__exit__å‡½æ•°\nclass File: def __enter__(self): def __exit__(self):é¢å‘å¯¹è±¡#\r__furture__#\rç”¨äºåœ¨ç±»æˆ–æšä¸¾ä¸­ä½¿ç”¨è‡ªå·±çš„ç±»å‹\nfrom __future__ import annotationsæšä¸¾#\rWARNING é€šå¸¸æšä¸¾ä¸å¯ä»¥ä½¿ç”¨@dataclassè£…é¥°å™¨ã€‚ä½†æ˜¯åœ¨è¿è¡Œæ—¶ä¸ä¼šæŠ¥é”™ã€‚\n# lsp ä¼šæç¤ºè¿™æ ·ä½¿ç”¨æ˜¯é”™è¯¯çš„ @dataclass class Type(Enum): # æ­£ç¡®ç”¨æ³• class Type(Enum): Some = Noneå®ä¾‹æ–¹æ³•Â·ç±»æ–¹æ³•Â·é™æ€æ–¹æ³•#\rTIP\nç±»æ–¹æ³•æ˜¯é’ˆå¯¹ç±»çš„ï¼Œå®ä¾‹æ–¹æ³•æ˜¯é’ˆå¯¹å®ä¾‹çš„ï¼Œé™æ€æ–¹æ³•æ˜¯é’ˆå¯¹ç±»å’Œå®ä¾‹çš„ã€‚\nç±»æ–¹æ³•å¸¸ç”¨äºæä¾›é¢å¤–çš„æ„é€ å¯¹è±¡çš„æ–¹å¼ï¼Œä½œä¸º__init__æ–¹æ³•çš„è¡¥å……ã€‚\n# é™æ€æ–¹æ³• @staticmethod # ç±»æ–¹æ³• @classmethodå‡½æ•°å¼ç¼–ç¨‹#\rpymonad#\rå‡½æ•°ç»„åˆ#\rCompose#\rä½¿ç”¨Composeçš„å‡½æ•°å¿…é¡»æœ‰ä¸€ä¸ªå‚æ•°ï¼Œå¯ä»¥ç”¨Noneä»£æ›¿ã€‚\nfrom pymonad.reader import Compose def add(placeHolder = None) -\u0026gt; int: return 3 Compose(add).then(mul)Pipe#\r"},{"id":9,"href":"/Programming-Notes/docs/notes/rust/lifetime/","title":"Lifetime","section":"Rust","content":"Rust ç”Ÿå‘½å‘¨æœŸ#\rå‡½æ•°ç”Ÿå‘½å‘¨æœŸæ ‡è¯†#\rç”Ÿå‘½å‘¨æœŸæ ‡è¯†çœç•¥è§„åˆ™#\r// æƒ…å†µ1ï¼šæ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ fn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str { // è‡ªåŠ¨æ¨å¯¼ä¸º fn first_word\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } // æƒ…å†µ2ï¼šå¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸ fn get_str(s: \u0026amp;str) -\u0026gt; \u0026amp;str { // è‡ªåŠ¨æ¨å¯¼ä¸º fn get_str\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str s } // æƒ…å†µ3ï¼šå¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ \u0026amp;self æˆ– \u0026amp;mut selfï¼Œé‚£ä¹ˆ self çš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸ struct StringWrapper { data: String, } impl StringWrapper { fn get_data(\u0026amp;self) -\u0026gt; \u0026amp;str { // è‡ªåŠ¨æ¨å¯¼ä¸º fn get_data\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;a self) -\u0026gt; \u0026amp;\u0026#39;a str \u0026amp;self.data } }fn print1(s: \u0026amp;str); // elided fn print2(s: \u0026amp;\u0026#39;_ str); // also elided fn print3\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;a str); // expanded fn debug1(lvl: usize, s: \u0026amp;str); // elided fn debug2\u0026lt;\u0026#39;a\u0026gt;(lvl: usize, s: \u0026amp;\u0026#39;a str); // expanded fn substr1(s: \u0026amp;str, until: usize) -\u0026gt; \u0026amp;str; // elided fn substr2\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;a str, until: usize) -\u0026gt; \u0026amp;\u0026#39;a str; // expanded fn get_mut1(\u0026amp;mut self) -\u0026gt; \u0026amp;mut dyn T; // elided fn get_mut2\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;a mut self) -\u0026gt; \u0026amp;\u0026#39;a mut dyn T; // expanded fn args1\u0026lt;T: ToCStr\u0026gt;(\u0026amp;mut self, args: \u0026amp;[T]) -\u0026gt; \u0026amp;mut Command; // elided fn args2\u0026lt;\u0026#39;a, \u0026#39;b, T: ToCStr\u0026gt;(\u0026amp;\u0026#39;a mut self, args: \u0026amp;\u0026#39;b [T]) -\u0026gt; \u0026amp;\u0026#39;a mut Command; // expanded fn other_args1\u0026lt;\u0026#39;a\u0026gt;(arg: \u0026amp;str) -\u0026gt; \u0026amp;\u0026#39;a str; // elided fn other_args2\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt;(arg: \u0026amp;\u0026#39;b str) -\u0026gt; \u0026amp;\u0026#39;a str; // expanded fn new1(buf: \u0026amp;mut [u8]) -\u0026gt; Thing\u0026lt;\u0026#39;_\u0026gt;; // elided - preferred fn new2(buf: \u0026amp;mut [u8]) -\u0026gt; Thing; // elided fn new3\u0026lt;\u0026#39;a\u0026gt;(buf: \u0026amp;\u0026#39;a mut [u8]) -\u0026gt; Thing\u0026lt;\u0026#39;a\u0026gt;; // expanded type FunPtr1 = fn(\u0026amp;str) -\u0026gt; \u0026amp;str; // elided type FunPtr2 = for\u0026lt;\u0026#39;a\u0026gt; fn(\u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str; // expanded type FunTrait1 = dyn Fn(\u0026amp;str) -\u0026gt; \u0026amp;str; // elided type FunTrait2 = dyn for\u0026lt;\u0026#39;a\u0026gt; Fn(\u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str; // expanded ç”Ÿå‘½å‘¨æœŸå˜å¼‚æ€§#\rfn assign\u0026lt;T\u0026gt;(input: \u0026amp;mut T, val: T) { *input = val; } fn main() { let mut hello: \u0026amp;\u0026#39;static str = \u0026#34;hello\u0026#34;; { let world = String::from(\u0026#34;world\u0026#34;); assign(\u0026amp;mut hello, \u0026amp;world); } println!(\u0026#34;{hello}\u0026#34;); // ä½¿ç”¨åœ¨è¢«é‡Šæ”¾åçš„å€¼ ğŸ˜¿ } TIP\nåå˜(covariant)ã€ä¸å˜(invariant)ã€é€†å˜(contravariant)\nåå˜(covariant)ï¼š\nå¦‚æœTæ˜¯åå˜çš„ä¸”Uæ˜¯Tçš„å­ç±»å‹ï¼Œé‚£ä¹ˆcontainer\u0026lt;T\u0026gt;çš„å­ç±»å‹æ˜¯container\u0026lt;U\u0026gt;ã€‚\né€†å˜(contravariant)ï¼š\nå¦‚æœTæ˜¯é€†å˜çš„ä¸”Uæ˜¯Tçš„å­ç±»å‹ï¼Œé‚£ä¹ˆcontainer\u0026lt;U\u0026gt;çš„å­ç±»å‹æ˜¯container\u0026lt;T\u0026gt;ã€‚\nä¸å˜(invariant)ï¼š\nä¸¤è€…æ²¡æœ‰ä»»ä½•å…³ç³»ã€‚\n\u0026lsquo;a T U \u0026amp;'a T covariant covariant \u0026amp;'a mut T covariant invariant *const T covariant *mut T invariant Box\u0026lt;T\u0026gt; covariant Vec\u0026lt;T\u0026gt; covariant UnsafeCell\u0026lt;T\u0026gt; invariant Cell\u0026lt;T\u0026gt; invariant fn(T) -\u0026gt; U covariant contravariant [T]å’Œ[T;n] covariant std::marker::PhantomData\u0026lt;T\u0026gt; covariant dyn Trait\u0026lt;T\u0026gt; + 'a covariant invariant NOTE\n\u0026amp;'a mut Tä¸­å…³äºTä¸ºä»€ä¹ˆæ˜¯ä¸å˜(invariant)çš„ã€‚å¦‚æœæ˜¯åå˜çš„é‚£ä¹ˆå½“ç¼©å‡äº†ç”Ÿå‘½å‘¨æœŸåå°±ä¼šå‡ºç°æ‚¬å‚æŒ‡é’ˆã€‚\nfn assign_short_string(x: \u0026amp;mut \u0026amp;\u0026#39;short str) { let s = String::from(\u0026#34;short\u0026#34;); *x = \u0026amp;s; // å°†çŸ­ç”Ÿå‘½å‘¨æœŸçš„å­—ç¬¦ä¸²èµ‹å€¼ç»™ *x } // s è¢«ä¸¢å¼ƒï¼Œæ‰€ä»¥ *x å˜æˆäº†æ‚¬å‚æŒ‡é’ˆ fn main() { let mut static_str: \u0026amp;\u0026#39;static str = \u0026#34;hello\u0026#34;; assign_short_string(\u0026amp;mut static_str); // å¦‚æœå…è®¸ï¼Œé‚£ä¹ˆ static_str ä¼šæŒ‡å‘ä¸€ä¸ªå·²é‡Šæ”¾çš„å­—ç¬¦ä¸² println!(\u0026#34;{}\u0026#34;, static_str); // ä½¿ç”¨æ‚¬å‚æŒ‡é’ˆ } é‡å€Ÿç”¨(ReBorrow)#\rTIP\n\u0026amp;'a T å®ç°äº†Copy traitï¼Œ \u0026amp;'a mut T æ²¡æœ‰å®ç°Copy traitã€‚\nlet mut i = 42; let x:\u0026amp;mut i32 = \u0026amp;mut i; let y:\u0026amp;mut i32 = x; // ç­‰ä»·äº let y:\u0026amp;mut i32 = \u0026amp;mut *x; // y é‡å€Ÿç”¨äº†i, åœ¨yå­˜æ´»æ—¶æœŸä¸å¯ä»¥ä½¿ç”¨xä¸iã€‚ "}]